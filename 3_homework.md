
# 3.58 *
For a function with prototype
```C
long decode2(long x, long y, long z);
```

gcc generates the following assembly code:
```
decode2:
	subq %rdx, %rsi
	imulq %rsi, %rdi
	movq %rsi, %rax
	salq $63, %rax
	sarq $63, %rax
	xorq %rdi, %rax
	ret
```
Parameters x, y, and z are passed in registers %rdi, %rsi, and %rdx. The code stores the return value in register %rax.
Write C code for decode2 that will have an effect equivalent to the assembly code shown.

**Solution**:
Analyze assembly code:
```
# long decode2(long x, long y, long z)
# rdi - x, rsi - y, rdx - z
decode2:
	subq %rdx, %rsi    # rsi=rsi-rdx: rsi = y - z
	imulq %rsi, %rdi   # rdi=rdi*rsi: rdi = x * (y - z)
	movq %rsi, %rax    # rax=rsi: rax = y - z
	salq $63, %rax     # rax=rax<<63: rax = (y-z)<<63
	sarq $63, %rax     # rax=rax>>63: rax = ((y-z)<<63)>>63
	xorq %rdi, %rax    # rax=rax^rdi: rax = ((y-z)<<63)>>63 ^ (x * (y - z))
	ret
```
Thus the C code:
```C
long decode2(long x, long y, long z)
{
	return ((y-z)<<63)>>63 ^ (x*(y-z));
}
```

# 3.59 **
The following code computes the 128-bit product of two 64-bit signed values x and y and stores the result in memory:
```c
typedef __int128 int128_t;

void store_prod(int128_t *dest, int64_t x, int64_t y) {
	*dest = x * (int128_t)y;
}
```
Gcc generates the following assembly code implementing the computation:
```
store_prod:
	movq    %rdx, %rax
	cqto
	movq    %rsi, %rcx
	sarq    $63, %rcx
	imulq   %rax, %rcx
	imulq   %rsi, %rdx
	addq    %rdx, %rcx
	mulq    %rsi
	addq    %rcx, %rdx
	movq    %rax, (%rdi)
	movq    %rdx, 8(%rdi)
	ret
```
This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. Hint: When extending arguments of x and y to 128 bits, they can be rewritten as $x = 2^{64} \times x_h + x_l$ and $y = 2^{64} \times y_h + y_l$, where $x_h$, $x_l$, $y_h$, and $y_l$ are 64-bit values. Similarly, the 128-bit product can be written as
$p = 2^{64} \times p_h + p_l$, where $p_h$ and $p_l$ are 64-bit values. Show how the code computes the values of $p_h$ and $p_l$ in terms of $x_h$, $x_l$, $y_h$, and $y_l$.

**Solution**:
* Firstly, let's analyze the theory:
	* For bit representation $[x_0,x_1 ... x_{63}]$, $x$ is its signed value and $ux$ is its unsigned value. 
	* Then $ux = x + 2^{64}*x_{63}$ while $x_{63}$ is the sign bit value of $x$.
	* So we also get same for $y$: $uy = y + 2^{64}*y_{63}$
	* Combined to get $x*y$: $x*y=(ux-2^{64}*x_{63})*(uy-2^{64}*y_{63})=ux*uy-(x_{63}*uy+y_{63}*ux)2^{64}$
	* Ok, now we get the formula, let's go through the assembly code.
* Analyze the assembly code:
```
# void store_prod(int128_t *dest, int64_t x, int64_t y)
# rdi - dest, rsi - x, rdx - y
store_prod:
	movq    %rdx, %rax     # rax=rdx: rax = y
	cqto                   # convert 64bits in rax to 128bits: 
	                       # rdx = y >> 63
	                       # rax = y
	movq    %rsi, %rcx     # rcx=rsi: rcx = x
	sarq    $63, %rcx      # rcx=rcx>>63: rcx = x>>63 - get the sign bit of x which is x63
	imulq   %rax, %rcx     # rcx=rcx*rax: rcx = y * (x>>63)
	imulq   %rsi, %rdx     # rdx=rdx*rsi: rdx = (y>>63) * x
	addq    %rdx, %rcx     # rcx=rcx+rdx: rcx = (y*(x>>63)) + ((y>>63)*x)
	mulq    %rsi           # rdx:rax=rax*rsi: rdx:rax = uy * ux
	addq    %rcx, %rdx     # rdx=rdx+rcx: rdx = rdx + (y*(x>>63)) + ((y>>63)*x) - high64bits operation
	movq    %rax, (%rdi)   # M(rdi)=rax: *dest = rax - set low 64 bits
	movq    %rdx, 8(%rdi)  # M(rdi+8)=rdx: *(dest+8) = rdx - set high 64 bits
	ret
```

# 3.60 **
Consider the following assembly code:
```
# long loop(long x, int n)
# x in %rdi, n in %esi

loop:
	movl %esi, %ecx
	movl $1, %edx
	movl $0, %eax
	jmp .L2

.L3:
	movq %rdi, %r8
	andq %rdx, %r8
	orq %r8, %rax
	salq %cl, %rdx

.L2:
	testq %rdx, %rdx
	jne .L3
	rep; ret
```
The preceding code was generated by compiling C code that had the following overall form:
```c
long loop(long x, long n)
{
	long result = ______;
	long mask;
	for (mask = ______; mask ______; mask = ______) {
		result |= ______;
	}
	return result;
}
```
Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register `%rax`. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.

A. Which registers hold program values x, n, result, and mask?

B. What are the initial values of result and mask?

C. What is the test condition for mask?

D. How does mask get updated?

E. How does result get updated?

F. Fill in all the missing parts of the C code.

**Solution**:
Firstly, analyze the assembly code:
```
# long loop(long x, int n)
# x in %rdi, n in %esi

loop:
	movl %esi, %ecx     # ecx=esi: ecx = n
	movl $1, %edx       # edx=1: edx = 1
	movl $0, %eax       # eax=0: eax = 0
	jmp .L2

.L3:
	movq %rdi, %r8      # r8=rdi: r8 = x
	andq %rdx, %r8      # r8=r8&rdx: r8 = x & rdx
	orq %r8, %rax       # rax=rax|r8: rax = rax | (x & rdx)
	salq %cl, %rdx      # rdx=rdx>>cl

.L2:
	testq %rdx, %rdx    
	jne .L3             # if rdx!=0, goto .L3 - rdx is mask
	rep; ret
```

A. Which registers hold program values x, n, result, and mask?
	mask - rdx
	result - rax
	x - rdi
	n - esi

B. What are the initial values of result and mask?
	`movl $0, %eax` - The initial value of result is 0.
	`movl $1, %edx` - The initial value of mask is 1.

C. What is the test condition for mask?
	`testq %rdx, %rdx` - `mask != 0`

D. How does mask get updated?
	`salq %cl, %rdx` - `mask << n`

E. How does result get updated?
	`andq %rdx, %r8` - `r8 = x & mask`
	`orq %r8, %rax` - `result = result | (x & mask)`

F. Fill in all the missing parts of the C code.
```c
long loop(long x, long n)
{
	long result = 0;
	long mask;
	for (mask = 1; mask != 0; mask = mask << n) {
		result |= (x & mask);
	}
	return result;
}
```

# 3.61 **
In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer:
```c
long cread(long *xp) {
	return (xp ? *xp : 0);
}
```
We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address.

Write a C function cread_alt that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions.

**Solution**:
If compile using a conditional move instruction, it would be like:
```
# long cread(long *xp)
# Invalid implementation of function cread
# xp in register %rdi

cread:
	movq (%rdi), %rax     # v = *xp
	testq %rdi, %rdi      # Test x
	movl $0, %edx         # Set ve = 0
	cmove %rdx, %rax      # If x==0, v = ve
	ret                   # Return v
```
which is:
```c
long cread(long *xp) {
	v = *xp;
	if x = 0
	ve = 0
	v = ve
	return v;
}
```
Obviously, we need to avoid the expression `*xp`.

If we change the source code to be:
```c
long cread(long *xp) {
	return (!xp ? 0 : *xp);
}
```
Then the pseudo-code would be:
```c
long cread(long *xp) {
	v = 0;
	if !xp = 0
	v = (*xp)
	return v;
}
```
So the assembly code would be:
```
cread:
	movq     $0, %rax          # v = 0
	testq    %rdi, %rdi        # Test x
	cmovne   (%rdi), %rax      # If x==0, v = ve
	ret                        # Return v
```


# 3.62 **
The code that follows shows an example of branching on an enumerated type value in a switch statement. Recall that enumerated types in C are simply a way to introduce a set of names having associated integer values. By default, the values assigned to the names count from zero upward. In our code, the actions associated with the different case labels have been omitted.
```c
/* Enumerated type creates set of constants numbered 0 and upward */
typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;

long switch3(long *p1, long *p2, mode_t action)
{
	long result = 0;
	switch(action) {
		case MODE_A:
		case MODE_B:
		case MODE_C:
		case MODE_D:
		case MODE_E:
		default:
	}
	return result;
}
```
The part of the generated assembly code implementing the different actions is shown below. The annotations indicate the argument locations, the register values, and the case labels for the different jump destinations.
```
# p1 in %rdi, p2 in %rsi, action in %edx

.L8:             # MODE_E
	movl $27, %eax
	ret

.L3:             # MODE_A
	movq (%rsi), %rax
	movq (%rdi), %rdx
	movq %rdx, (%rsi)
	ret

.L5:             # MODE_B
	movq (%rdi), %rax
	addq (%rsi), %rax
	movq %rax, (%rdi)
	ret

.L6:             # MODE_C
	movq $59, (%rdi)
	movq (%rsi), %rax
	ret

.L7:             # MODE_D
	movq (%rsi), %rax
	movq %rax, (%rdi)
	movl $27, %eax
	ret

.L9:             # default
	movl $12, %eax
	ret
```

Fill in the missing parts of the C code. It contained one case that fell through to another—try to reconstruct this.

**Solution**:
```
# p1 in %rdi, p2 in %rsi, action in %edx

.L8:             # MODE_E
	movl $27, %eax           # eax = 27
	ret

.L3:             # MODE_A
	movq (%rsi), %rax        # rax = M(rsi): rax = *(p2)
	movq (%rdi), %rdx        # rdx = M(rdi): rdx = *(p1)
	movq %rdx, (%rsi)        # M(rsi) = rdx: *(p2) = rdx = *(p1)
	ret

.L5:             # MODE_B
	movq (%rdi), %rax        # rax = M(rdi): rax = *(p1)
	addq (%rsi), %rax        # rax = rax + M(rsi): rax = *(p2) + *(p1)
	movq %rax, (%rdi)        # M(rdi) = rax: *p1 = rax = *(p2) + *(p1)
	ret

.L6:             # MODE_C
	movq $59, (%rdi)         # M(rdi) = 59: (*p1) = 59
	movq (%rsi), %rax        # rax = M(rsi): rax = *p2
	ret

.L7:             # MODE_D
	movq (%rsi), %rax        # rax = M(rsi): rax = *p2
	movq %rax, (%rdi)        # M(rdi) = rax: (*p1) = rax = (*p2)
	movl $27, %eax           # eax = 27
	ret

.L9:             # default
	movl $12, %eax           # eax = 12
	ret
```
So we can get the C code below:
```c
/* Enumerated type creates set of constants numbered 0 and upward */
typedef enum {MODE_A, MODE_B, MODE_C, MODE_D, MODE_E} mode_t;

long switch3(long *p1, long *p2, mode_t action)
{
	long result = 0;
	switch(action) {
		case MODE_A:
			result = *p2;
			*(p2) = *(p1);
			break;
		
		case MODE_B:
			result = *(p2) + *(p1);
			*p1 = result;
			break;
			
		case MODE_C:
			(*p1) = 59;
			result = *p2;
			break;
			
		case MODE_D:
			(*p1) = (*p2);
			result = 27;
			break;
			
		case MODE_E:
			result = 27;
			break;
			
		default:
			result = 12;
	}
	return result;
}
```

# 3.63 **
This problem will give you a chance to reverse engineer a switch statement from disassembled machine code. In the following procedure, the body of the switch statement has been omitted:
```c
long switch_prob(long x, long n) {
	long result = x;
	switch(n) {
		/* Fill in code here */
	}
	return result;
}
```
Figure below shows the disassembled machine code for the procedure:
```
# long switch_prob(long x, long n)
# x in %rdi, n in %rsi

0000000000400590 <switch_prob>:
	400590: 48 83 ee 3c             sub  $0x3c,%rsi
	400594: 48 83 fe 05             cmp  $0x5,%rsi
	400598: 77 29                   ja   4005c3 <switch_prob+0x33>
	40059a: ff 24 f5 f8 06 40 00    jmpq *0x4006f8(,%rsi,8)
	4005a1: 48 8d 04 fd 00 00 00    lea  0x0(,%rdi,8),%rax
	4005a8: 00
	4005a9: c3                      retq
	4005aa: 48 89 f8                mov  %rdi,%rax
	4005ad: 48 c1 f8 03             sar  $0x3,%rax
	4005b1: c3                      retq
	4005b2: 48 89 f8                mov  %rdi,%rax
	4005b5: 48 c1 e0 04             shl  $0x4,%rax
	4005b9: 48 29 f8                sub  %rdi,%rax
	4005bc: 48 89 c7                mov  %rax,%rdi
	4005bf: 48 0f af ff             imul %rdi,%rdi
	4005c3: 48 8d 47 4b             lea  0x4b(%rdi),%rax
	4005c7: c3                      retq
```

The jump table resides in a different area of memory. We can see from the indirect jump on line 5 that the jump table begins at address 0x4006f8. Using the gdb debugger, we can examine the six 8-byte words of memory comprising the jump table with the command x/6gx 0x4006f8. Gdb prints the following:
```shell
(gdb) x/6gx 0x4006f8

0x4006f8: 0x00000000004005a1 0x00000000004005c3
0x400708: 0x00000000004005a1 0x00000000004005aa
0x400718: 0x00000000004005b2 0x00000000004005bf
```

Fill in the body of the switch statement with C code that will have the same behavior as the machine code.

**Solution**:
We look into the assembly code:
```
# long switch_prob(long x, long n)
# x in %rdi, n in %rsi

0000000000400590 <switch_prob>:
	400590: 48 83 ee 3c             sub  $0x3c,%rsi                 # rsi=rsi-0x3c: n = n - 0x3c
	400594: 48 83 fe 05             cmp  $0x5,%rsi                  # cmp 5 and rsi: cmp 5 and n-0x3c
	400598: 77 29                   ja   4005c3 <switch_prob+0x33>  # if n-0x3c > 5, goto 4005c3
	40059a: ff 24 f5 f8 06 40 00    jmpq *0x4006f8(,%rsi,8)         # goto *(0x4006f8+8*rsi)
	4005a1: 48 8d 04 fd 00 00 00    lea  0x0(,%rdi,8),%rax          # if rsi=0 or 2, rax=8*rdi: 
	                                                                # if n - 0x3c = 0, result = 8*x
	4005a8: 00
	4005a9: c3                      retq
	4005aa: 48 89 f8                mov  %rdi,%rax                  # if rsi=3, rax=rdi
	                                                                # if n - 0x3c = 3, result = x
	4005ad: 48 c1 f8 03             sar  $0x3,%rax                  # rax=rax>>3: result = x/8
	4005b1: c3                      retq
	4005b2: 48 89 f8                mov  %rdi,%rax                  # if rsi=4, rax=rdi
	                                                                # if n - 0x3c = 4, result = x
	4005b5: 48 c1 e0 04             shl  $0x4,%rax                  # rax=rax<<4: result = x*16
	4005b9: 48 29 f8                sub  %rdi,%rax                  # rax=rax-rdi: result = 15*x
	4005bc: 48 89 c7                mov  %rax,%rdi                  # rdi=rax: rdi = 15*x
	
	4005bf: 48 0f af ff             imul %rdi,%rdi                  # sharedcode - rdi=rdi*rdi
	4005c3: 48 8d 47 4b             lea  0x4b(%rdi),%rax            # sharedcode - if rsi=1, rax=rdi+0x4b                                                        # rax = rdi + 0x4b
	                                                                # sharedcode - if n - 0x3c = 1, result = x + 0x4b
	4005c7: c3                      retq
```

Then construct the C code:
```c
long switch_prob(long x, long n) {
	long result = x;
	switch(n) {
		/* Fill in code here */
		case 0x3c:        // rsi = 0
		case 0x3e:        // rsi = 2
			result = 8*x;
			break;
		case 0x3f:        // rsi = 3
			result = x/8;
			break;
		case 0x40:        // rsi = 4
			result = 15*x*15*x + 0x4b;
			break;
		default:        // rsi = 1
			result = x + 0x4b;
	}
	return result;
}
```

# 3.64 ***
Consider the following source code, where R, S, and T are constants declared with #define:
```c
long A[R][S][T];

long store_ele(long i, long j, long k, long *dest)
{
	*dest = A[i][j][k];
	return sizeof(A);
}
```
In compiling this program, gcc generates the following assembly code:
```
# long store_ele(long i, long j, long k, long *dest)
# i in %rdi, j in %rsi, k in %rdx, dest in %rcx

store_ele:
	leaq (%rsi,%rsi,2), %rax
	leaq (%rsi,%rax,4), %rax
	movq %rdi, %rsi
	salq $6, %rsi
	addq %rsi, %rdi
	addq %rax, %rdi
	addq %rdi, %rdx
	movq A(,%rdx,8), %rax
	movq %rax, (%rcx)
	movl $3640, %eax
	ret
```
A. Extend Equation 3.1 from two dimensions to three to provide a formula for the location of array element `A[i][j][k]`.

B. Use your reverse engineering skills to determine the values of R, S, and T based on the assembly code.

**Solution**:
A.
What is euqation 3.1?
T  D\[R\]\[C\];
$\&D[i][j] = x_D + L(C \times i + j)$
This is for 2 dimensions' array. When doing on 3 dimensions' array, it's like:
T  A\[R\]\[S\]\[T\];
$\&A[i][j][k] = x_A + L(S*T*i + T*j + k)$;

B.
```
# long store_ele(long i, long j, long k, long *dest)
# i in %rdi, j in %rsi, k in %rdx, dest in %rcx

store_ele:
	leaq (%rsi,%rsi,2), %rax   # rax=3*rsi:  rax = 3j
	leaq (%rsi,%rax,4), %rax   # rax=rsi+4*rax: rax = j + 12j = 13j
	movq %rdi, %rsi            # rsi=rdi: rsi = i
	salq $6, %rsi              # rsi=rsi<<6: rsi = 64i
	addq %rsi, %rdi            # rdi=rdi+rsi: rdi = i + 64i = 65i
	addq %rax, %rdi            # rdi=rdi+rax: rdi = 65i + 13j
	addq %rdi, %rdx            # rdx=rdx+rdi: rdx = k + 65i + 13j
	movq A(,%rdx,8), %rax      # rax=A+8*rdx: rax = A + 8(k + 65i + 13j)
	movq %rax, (%rcx)          # M(rcx)=rax: *dest = A + 8(k + 65i + 13j)
	movl $3640, %eax           # eax=3640
	ret
```
Thus, we get `*dest = A + 8(k + 65i + 13j)`
From all the information, we get:
$R*S*T*8=3640$
$S*T=65$
$T=13$
$S=5$
$R=7$

# 3.65 *
The following code transposes the elements of an M × M array, where M is a constant defined by #define:
```c
void transpose(long A[M][M]) {
	long i, j;
	for (i = 0; i < M; i++)
		for (j = 0; j < i; j++) {
			long t = A[i][j];
			A[i][j] = A[j][i];
			A[j][i] = t;
		}
}
```
When compiled with optimization level -O1, gcc generates the following code for the inner loop of the function:
```
.L6:
	movq (%rdx), %rcx
	movq (%rax), %rsi
	movq %rsi, (%rdx)
	movq %rcx, (%rax)
	addq $8, %rdx
	addq $120, %rax
	cmpq %rdi, %rax
	jne .L6
```
We can see that gcc has converted the array indexing to pointer code.

A. Which register holds a pointer to array element A\[i\]\[j\]?

B. Which register holds a pointer to array element A\[j\]\[i\]?

C. What is the value of M?

**Solution**:
Look into the assembly code:
```
# void transpose(long A[M][M])
# rdi - A
.L6:
	movq (%rdx), %rcx     # rcx=M(rdx): rcx = A[i][j]
	movq (%rax), %rsi     # rsi=M(rax): rsi = A[j][i]
	movq %rsi, (%rdx)     # M(rdx)=rsi:  
	movq %rcx, (%rax)     # M(rax)=rcx:
	addq $8, %rdx         # rdx=rdx+8: (&A[i][j])++
	addq $120, %rax       # rax=rax+120: &A[j][i] = &A[j][i] + j
	cmpq %rdi, %rax
	jne .L6
```

A.
rdx

B.
rax

C.
15

# 3.66 *
Consider the following source code, where NR and NC are macro expressions declared with #define that compute the dimensions of array A in terms of parameter n. This code computes the sum of the elements of column j of the array.
```c
long sum_col(long n, long A[NR(n)][NC(n)], long j) {
	long i;
	long result = 0;
	for (i = 0; i < NR(n); i++)
		result += A[i][j];
	return result;
}
```

In compiling this program, gcc generates the following assembly code:
```
# long sum_col(long n, long A[NR(n)][NC(n)], long j)
# n in %rdi, A in %rsi, j in %rdx

sum_col:
	leaq   1(,%rdi,4), %r8
	leaq   (%rdi,%rdi,2), %rax
	movq   %rax, %rdi
	testq  %rax, %rax
	jle    .L4
	salq   $3, %r8
	leaq   (%rsi,%rdx,8), %rcx
	movl   $0, %eax
	movl   $0, %edx

.L3:
	addq   (%rcx), %rax
	addq   $1, %rdx
	addq   %r8, %rcx
	cmpq   %rdi, %rdx
	jne    .L3
	rep; ret

.L4:
	movl   $0, %eax
	ret
```

Use your reverse engineering skills to determine the definitions of NR and NC.

**Solution**:
Look into the assembly code:
```
# long sum_col(long n, long A[NR(n)][NC(n)], long j)
# n in %rdi, A in %rsi, j in %rdx

sum_col:
	leaq   1(,%rdi,4), %r8       # r8=4*rdi+1: r8 = 4n + 1
	leaq   (%rdi,%rdi,2), %rax   # rax=3*rdi: rax = 3n
	movq   %rax, %rdi            # rdi=rax: rdi = 3n
	testq  %rax, %rax
	jle    .L4                   # if 3n <= 0, goto .L4
	salq   $3, %r8               # r8=r8<<3: r8 = 8*r8 = 8*(4n+1)
	leaq   (%rsi,%rdx,8), %rcx   # rcx=rsi+8*rdx: rcx = A + 8j
	movl   $0, %eax              # eax = 0
	movl   $0, %edx              # edx = 0

.L3:
	addq   (%rcx), %rax          # rax+=M(rcx): rax = rax + *(A+8j)
	addq   $1, %rdx              # rdx+=1: i++
	addq   %r8, %rcx             # rcx+=r8: rcx = rcx + 8*(4n+1)
	cmpq   %rdi, %rdx
	jne    .L3                   # if rdx!=rdi, goto .L3
	rep; ret

.L4:
	movl   $0, %eax
	ret
```

Thus we get that: in loop, rcx is A\[i\]\[j\]

From `addq   %r8, %rcx # rcx+=r8: rcx = rcx + 8*(4n+1)`, we get that NC(n) = 4n + 1
From `cmpq   %rdi, %rdx`, we get that NR(n) = 3n

# 3.67 **
For this exercise, we will examine the code generated by gcc for functions that have structures as arguments and return values, and from this see how these language features are typically implemented.

The following C code has a function process having structures as argument and return values, and a function eval that calls process:
```c
typedef struct {
	long a[2];
	long *p;
} strA;

typedef struct {
	long u[2];
	long q;
} strB;

strB process(strA s) {
	strB r;
	r.u[0] = s.a[1];
	r.u[1] = s.a[0];
	r.q = *s.p;
	return r;
}

long eval(long x, long y, long z) {
	strA s;
	s.a[0] = x;
	s.a[1] = y;
	s.p = &z;
	strB r = process(s);
	return r.u[0] + r.u[1] + r.q;
}
```

Gcc generates the following code for these two functions:
```
# strB process(strA s)

process:
	movq %rdi, %rax
	movq 24(%rsp), %rdx
	movq (%rdx), %rdx
	movq 16(%rsp), %rcx
	movq %rcx, (%rdi)
	movq 8(%rsp), %rcx
	movq %rcx, 8(%rdi)
	movq %rdx, 16(%rdi)
	ret

# long eval(long x, long y, long z)
# x in %rdi, y in %rsi, z in %rdx

eval:
	subq $104, %rsp
	movq %rdx, 24(%rsp)
	leaq 24(%rsp), %rax
	movq %rdi, (%rsp)
	movq %rsi, 8(%rsp)
	movq %rax, 16(%rsp)
	leaq 64(%rsp), %rdi
	call process
	movq 72(%rsp), %rax
	addq 64(%rsp), %rax
	addq 80(%rsp), %rax
	addq $104, %rsp
	ret
```

A. We can see on line 18 of function eval that it allocates 104 bytes on the stack. Diagram the stack frame for eval, showing the values that it stores on the stack prior to calling process.

B. What value does eval pass in its call to process?

C. How does the code for process access the elements of structure argument s?

D. How does the code for process set the fields of result structure r?

E. Complete your diagram of the stack frame for eval, showing how eval accesses the elements of structure r following the return from process.

F. What general principles can you discern about how structure values are passed as function arguments and how they are returned as function results?

**Solution**:

A.

| Address  | Relating Instruction                       | value                 | size         |
| -------- | ------------------------------------------ | --------------------- | ------------ |
| %rsp+104 |                                            |                       |              |
| ...      |                                            |                       |              |
| %rsp+24  | movq %rdx, 24(%rsp)                        | z                     | sizeof(long) |
| %rsp+16  | leaq 24(%rsp), %rax<br>movq %rax, 16(%rsp) | %rsp+24<br>/ &z / s.p | 64 bits      |
| %rsp+8   | movq %rsi, 8(%rsp)                         | y/s.a[1]              | sizeof(long) |
| %rsp     | movq %rdi, (%rsp)                          | x/s.a[0]              | sizeof(long) |
B.
`%rsp + 64` according to `leaq 64(%rsp), %rdi`.

C.
`%rsp + offset`

D.
When run into process function, the stack is like:

| Address  | Relating Instruction                       | value           | size         |
| -------- | ------------------------------------------ | --------------- | ------------ |
| %rsp+112 |                                            |                 |              |
| ...      |                                            |                 |              |
| %rsp+72  |                                            |                 |              |
| ...      |                                            |                 |              |
| %rsp+32  | movq %rdx, 24(%rsp)                        | z               | sizeof(long) |
| %rsp+24  | leaq 24(%rsp), %rax<br>movq %rax, 16(%rsp) | %rsp+32<br>/ &z | 64 bits      |
| %rsp+16  | movq %rsi, 8(%rsp)                         | y               | sizeof(long) |
| %rsp+8   | movq %rdi, (%rsp)                          | x               | sizeof(long) |
| %rsp     | call process                               | return address  | 64 bits      |
Copy the process C code here:
```c
strB process(strA s) {
	strB r;
	r.u[0] = s.a[1];
	r.u[1] = s.a[0];
	r.q = *s.p;
	return r;
}
```
Look into the process assembly language:
```
# strB process(strA s)
# the eval pass s=rsp+64 as parameter
process:
	movq %rdi, %rax        # rax=rdi: rax = rsp+72
	movq 24(%rsp), %rdx    # rdx=M(rsp+24): rdx = &z
	movq (%rdx), %rdx      # rdx=M(rdx): rdx = z
	movq 16(%rsp), %rcx    # rcx=M(rsp+16): rcx = y
	movq %rcx, (%rdi)      # M(rdi)=rcx: M(rsp+72) = r.u[0] = y
	movq 8(%rsp), %rcx     # rcx=M(rsp+8): rcx = x
	movq %rcx, 8(%rdi)     # M(rdi+8)=rcx: M(rsp+80) = r.u[1] = x
	movq %rdx, 16(%rdi)    # M(rdi+16)=rdx: M(rsp+88) = r.q = z
	ret
```
* We find that:
	* even though in C code: `strB r = process(s)`, it's calling process by passing `strA s` as a parameter.
	* gcc actually use rsp+64 as the address of `r`.

E.
After return from function process, the return address is popped from stack then the stack will shrink by 8 bytes: `rsp = rsp + 8`. So we get the stack below:

| Address  | value           | size         |
| -------- | --------------- | ------------ |
| %rsp+104 |                 |              |
| ...      |                 |              |
| %rsp+80  | z / r.q         | sizeof(long) |
| %rsp+72  | x / r.u[1]      | sizeof(long) |
| %rsp+64  | y / r.u[0]      | sizeof(long) |
| ...      |                 |              |
| %rsp+24  | z               | sizeof(long) |
| %rsp+16  | %rsp+32<br>/ &z | 64 bits      |
| %rsp+8   | y               | sizeof(long) |
| %rsp+0   | x               | sizeof(long) |
Then look into the assembly code below:
```
	movq 72(%rsp), %rax    # rax = M(rsp+72) = x
	addq 64(%rsp), %rax    # rax += M(rsp+64) = y: rax = x + y
	addq 80(%rsp), %rax    # rax += M(rsp+80) = z: rax = x + y + z
```

F.
caller find space and pass space address to callee, callee store data on this space area and return this address.

# 3.68 ***
In the following code, A and B are constants defined with #define:
```c
typedef struct {
	int x[A][B]; /* Unknown constants A and B */
	long y;
} str1;

typedef struct {
	char array[B];
	int t;
	short s[A];
	long u;
} str2;

void setVal(str1 *p, str2 *q) {
	long v1 = q->t;
	long v2 = q->u;
	p->y = v1+v2;
}
```
Gcc generates the following code for setVal:
```
# void setVal(str1 *p, str2 *q)
# p in %rdi, q in %rsi

setVal:
	movslq 8(%rsi), %rax
	addq 32(%rsi), %rax
	movq %rax, 184(%rdi)
	ret
```
What are the values of A and B? (The solution is unique.)

**Solution**:
Look into the assembly code first:
```
# void setVal(str1 *p, str2 *q)
# p in %rdi, q in %rsi

setVal:
	movslq   8(%rsi), %rax    # rax=M(rsi+8): rax = *(q+8)
	addq     32(%rsi), %rax   # rax=rax+M(rsi+32): rax = rax + *(q+32)
	movq     %rax, 184(%rdi)  # M(rdi+184)=rax: *(p+184) = rax
	ret
```
Compare with the C code:
```c
void setVal(str1 *p, str2 *q) {
	long v1 = q->t;   
	long v2 = q->u;
	p->y = v1+v2;
}
```
Easy to find that:
* `q->t` equals `*(q+8)`
* `q->u` equals `*(q+32)`
* `p->y` equals `*(p+184)`
But we need to consider alignment, which means it's not so exactly.
For str2 struct:
```c
typedef struct {
	char array[B];
	int t;
	short s[A];
	long u;
} str2;
```
* For `q->t` equals `*(q+8)`, we get that 4 < B <= 8.
* For `q->u` equals `*(q+32)`, we get that 24 < B + 4 + 2*\A <=32, thus `20 < B + 2*A <=28`.
```c
typedef struct {
	int x[A][B]; /* Unknown constants A and B */
	long y;
} str1;
```
* For `p->y` equals `*(p+184)`, we get that 176 < 4\*A\*B <=184, thus 44 < A\*B <= 46.
* According to the information above, we get that: `A=9, B=5`

# 3.69 ◆◆◆

You are charged with maintaining a large C program, and you come across the
following code:
```c
typedef struct {
	int first;
	a_struct a[CNT];
	int last;
} b_struct;

void test(long i, b_struct *bp)
{
	int n = bp->first + bp->last;
	a_struct *ap = &bp->a[i];
	ap->x[ap->idx] = n;
}
```
The declarations of the compile-time constant CNT and the structure a_struct are in a file for which you do not have the necessary access privilege. Fortunately, you have a copy of the .o version of code, which you are able to disassemble with the objdump program, yielding the following disassembly:
```
0000000000000000 <test>: 
	0: 8b 8e 20 01 00 00     mov 0x120(%rsi), %ecx 
	6: 03 0e                 add (%rsi), %ecx 
	8: 48 8d 04 bf           lea (%rdi, %rdi, 4), %rax 
	c: 48 8d 04 c6           lea (%rsi, %rax, 8), %rax 
	10: 48 8b 50 08          mov 0x8(%rax), %rdx 
	14: 48 63 c9             movslq %ecx, %rcx 
	17: 48 89 4c d0 10       mov %rcx, 0x10(%rax, %rdx, 8) 
	1c: c3 retq
```
Using your reverse engineering skills, deduce the following:

A. The value of CNT.

B. A complete declaration of structure a_struct. Assume that the only fields in this structure are idx and x, and that both of these contain signed values.

**Solution**:
Reverse the assembly code and also put the structB here for convenience:
```c
typedef struct {
	int first;
	a_struct a[CNT];
	int last;
} b_struct;
```

```
# void test(long i, b_struct *bp)
# rdi - i
# rsi - bp

0000000000000000 <test>: 
	0:  mov 0x120(%rsi), %ecx           # ecx=M(rsi+0x120): ecx = bp->last
	6:  add (%rsi), %ecx                # ecx=ecx+M(rsi): ecx = bp->last + bp->first
	8:  lea (%rdi, %rdi, 4), %rax       # rax=5*rdi: rax = 5i
	c:  lea (%rsi, %rax, 8), %rax       # rax=rsi+8*rax: rax = bp + 8*5i
	10: mov 0x8(%rax), %rdx             # rdx=M(rax+8): rdx = M(bp + 8*5i + 8) = bp->a[i].idx = ap->idx
	14: movslq %ecx, %rcx               # rcx=ecx
	17: mov %rcx, 0x10(%rax, %rdx, 8)   # M(rax+8*rdx+0x10)=rcx
	1c: retq
```

A. 
From `lea (%rsi, %rax, 8), %rax  # rax=rsi+8*rax: rax = bp + 8*5i`, we get that the size of a_struct is 40 bytes including alignment.

We must know that the alignment is 8 bytes.
From `mov 0x120(%rsi), %ecx # ecx=M(rsi+0x120): ecx = bp->last`, we get that CNT = (0x120 - 8)/40 = 7.

B.
After reversing the assembly code and compare to the original C code, we get the following useful information:
* We easily get: `bp->a[i]` is `M(bp + 8*5i + 8)`, which is also `ap->idx` stored in `rdx`.
* Thus the 1st element is a_struct is `idx`.
* Then let's analyze this one: `mov %rcx, 0x10(%rax, %rdx, 8)   # M(rax+8*rdx+0x10)=rcx` step by step.
	* `rax+0x8` is `bp+8`, which is `&bp->a[i]`
	* `rax+0x8+0x8` is `&bp->a[i] + 0x8`, which is `&bp->a[i].x`. `idx` is 8 bytes.
	* `rax+8*rdx+0x10` is `&bp->a[i].x + 8*rdx`, which is `&ap->x + 8*rdx`, then `&ap->x[ap->idx]`. 
Now we know that: 1. the size of a_struct is 40 bytes, 2. the 1st element of a_struct is 8 bytes (`idx`), 3. the size of a in a_struct is 8 bytes.
We easily get the a_struct below:
```c
typedef struct 
{ 
	long idx; 
	long x[4]; 
} a_struct;
```








