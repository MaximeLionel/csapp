
# 3.58 *
For a function with prototype
```C
long decode2(long x, long y, long z);
```

gcc generates the following assembly code:
```
decode2:
	subq %rdx, %rsi
	imulq %rsi, %rdi
	movq %rsi, %rax
	salq $63, %rax
	sarq $63, %rax
	xorq %rdi, %rax
	ret
```
Parameters x, y, and z are passed in registers %rdi, %rsi, and %rdx. The code stores the return value in register %rax.
Write C code for decode2 that will have an effect equivalent to the assembly code shown.

**Solution**:
Analyze assembly code:
```
# long decode2(long x, long y, long z)
# rdi - x, rsi - y, rdx - z
decode2:
	subq %rdx, %rsi    # rsi=rsi-rdx: rsi = y - z
	imulq %rsi, %rdi   # rdi=rdi*rsi: rdi = x * (y - z)
	movq %rsi, %rax    # rax=rsi: rax = y - z
	salq $63, %rax     # rax=rax<<63: rax = (y-z)<<63
	sarq $63, %rax     # rax=rax>>63: rax = ((y-z)<<63)>>63
	xorq %rdi, %rax    # rax=rax^rdi: rax = ((y-z)<<63)>>63 ^ (x * (y - z))
	ret
```
Thus the C code:
```C
long decode2(long x, long y, long z)
{
	return ((y-z)<<63)>>63 ^ (x*(y-z));
}
```

# 3.59 **
The following code computes the 128-bit product of two 64-bit signed values x and y and stores the result in memory:
```c
typedef __int128 int128_t;

void store_prod(int128_t *dest, int64_t x, int64_t y) {
	*dest = x * (int128_t)y;
}
```
Gcc generates the following assembly code implementing the computation:
```
store_prod:
	movq    %rdx, %rax
	cqto
	movq    %rsi, %rcx
	sarq    $63, %rcx
	imulq   %rax, %rcx
	imulq   %rsi, %rdx
	addq    %rdx, %rcx
	mulq    %rsi
	addq    %rcx, %rdx
	movq    %rax, (%rdi)
	movq    %rdx, 8(%rdi)
	ret
```
This code uses three multiplications for the multiprecision arithmetic required to implement 128-bit arithmetic on a 64-bit machine. Describe the algorithm used to compute the product, and annotate the assembly code to show how it realizes your algorithm. Hint: When extending arguments of x and y to 128 bits, they can be rewritten as $x = 2^{64} \times x_h + x_l$ and $y = 2^{64} \times y_h + y_l$, where $x_h$, $x_l$, $y_h$, and $y_l$ are 64-bit values. Similarly, the 128-bit product can be written as
$p = 2^{64} \times p_h + p_l$, where $p_h$ and $p_l$ are 64-bit values. Show how the code computes the values of $p_h$ and $p_l$ in terms of $x_h$, $x_l$, $y_h$, and $y_l$.

**Solution**:
* Firstly, let's analyze the theory:
	* For bit representation $[x_0,x_1 ... x_{63}]$, $x$ is its signed value and $ux$ is its unsigned value. 
	* Then $ux = x + 2^{64}*x_{63}$ while $x_{63}$ is the sign bit value of $x$.
	* So we also get same for $y$: $uy = y + 2^{64}*y_{63}$
	* Combined to get $x*y$: $x*y=(ux-2^{64}*x_{63})*(uy-2^{64}*y_{63})=ux*uy-(x_{63}*uy+y_{63}*ux)2^{64}$
	* Ok, now we get the formula, let's go through the assembly code.
* Analyze the assembly code:
```
# void store_prod(int128_t *dest, int64_t x, int64_t y)
# rdi - dest, rsi - x, rdx - y
store_prod:
	movq    %rdx, %rax     # rax=rdx: rax = y
	cqto                   # convert 64bits in rax to 128bits: 
	                       # rdx = y >> 63
	                       # rax = y
	movq    %rsi, %rcx     # rcx=rsi: rcx = x
	sarq    $63, %rcx      # rcx=rcx>>63: rcx = x>>63 - get the sign bit of x which is x63
	imulq   %rax, %rcx     # rcx=rcx*rax: rcx = y * (x>>63)
	imulq   %rsi, %rdx     # rdx=rdx*rsi: rdx = (y>>63) * x
	addq    %rdx, %rcx     # rcx=rcx+rdx: rcx = (y*(x>>63)) + ((y>>63)*x)
	mulq    %rsi           # rdx:rax=rax*rsi: rdx:rax = uy * ux
	addq    %rcx, %rdx     # rdx=rdx+rcx: rdx = rdx + (y*(x>>63)) + ((y>>63)*x) - high64bits operation
	movq    %rax, (%rdi)   # M(rdi)=rax: *dest = rax - set low 64 bits
	movq    %rdx, 8(%rdi)  # M(rdi+8)=rdx: *(dest+8) = rdx - set high 64 bits
	ret
```

# 3.60 **
Consider the following assembly code:
```
# long loop(long x, int n)
# x in %rdi, n in %esi

loop:
	movl %esi, %ecx
	movl $1, %edx
	movl $0, %eax
	jmp .L2

.L3:
	movq %rdi, %r8
	andq %rdx, %r8
	orq %r8, %rax
	salq %cl, %rdx

.L2:
	testq %rdx, %rdx
	jne .L3
	rep; ret
```
The preceding code was generated by compiling C code that had the following overall form:
```c
long loop(long x, long n)
{
	long result = ______;
	long mask;
	for (mask = ______; mask ______; mask = ______) {
		result |= ______;
	}
	return result;
}
```
Your task is to fill in the missing parts of the C code to get a program equivalent to the generated assembly code. Recall that the result of the function is returned in register `%rax`. You will find it helpful to examine the assembly code before, during, and after the loop to form a consistent mapping between the registers and the program variables.

A. Which registers hold program values x, n, result, and mask?

B. What are the initial values of result and mask?

C. What is the test condition for mask?

D. How does mask get updated?

E. How does result get updated?

F. Fill in all the missing parts of the C code.

**Solution**:
Firstly, analyze the assembly code:
```
# long loop(long x, int n)
# x in %rdi, n in %esi

loop:
	movl %esi, %ecx     # ecx=esi: ecx = n
	movl $1, %edx       # edx=1: edx = 1
	movl $0, %eax       # eax=0: eax = 0
	jmp .L2

.L3:
	movq %rdi, %r8      # r8=rdi: r8 = x
	andq %rdx, %r8      # r8=r8&rdx: r8 = x & rdx
	orq %r8, %rax       # rax=rax|r8: rax = rax | (x & rdx)
	salq %cl, %rdx      # rdx=rdx>>cl

.L2:
	testq %rdx, %rdx    
	jne .L3             # if rdx!=0, goto .L3 - rdx is mask
	rep; ret
```

A. Which registers hold program values x, n, result, and mask?
	mask - rdx
	result - rax
	x - rdi
	n - esi

B. What are the initial values of result and mask?
	`movl $0, %eax` - The initial value of result is 0.
	`movl $1, %edx` - The initial value of mask is 1.

C. What is the test condition for mask?
	`testq %rdx, %rdx` - `mask != 0`

D. How does mask get updated?
	`salq %cl, %rdx` - `mask << n`

E. How does result get updated?
	`andq %rdx, %r8` - `r8 = x & mask`
	`orq %r8, %rax` - `result = result | (x & mask)`

F. Fill in all the missing parts of the C code.
```c
long loop(long x, long n)
{
	long result = 0;
	long mask;
	for (mask = 1; mask != 0; mask = mask << n) {
		result |= (x & mask);
	}
	return result;
}
```

# 3.61 **
In Section 3.6.6, we examined the following code as a candidate for the use of conditional data transfer:
```c
long cread(long *xp) {
	return (xp ? *xp : 0);
}
```
We showed a trial implementation using a conditional move instruction but argued that it was not valid, since it could attempt to read from a null address.

Write a C function cread_alt that has the same behavior as cread, except that it can be compiled to use conditional data transfer. When compiled, the generated code should use a conditional move instruction rather than one of the jump instructions.

**Solution**:
